'''
программа должна понимать параметры командной строки:
    роль - определяет будет ли приложение отправлять данные или принимать данные
    --role send/recieve
    
    имя сервера - полное имя сервера или ip-адрес сервера с которым программа будет взаимодействовать 
(используется только для роли отправляющей данные)
    --server 

    ip-адрес и порт на котором будет запущен сервис приема данных (используется только для роли принимающей данные)
    --ip --port

программа должна включать один package в котором:
    создан класс MySender и:
        - конструктор, принимающий на вход реквизиты сервера для подключения
        - protected метод который генерирует случайную последовательность байт размером до 8 ГБ, максимальный размер 
        устанавливается константой
    
        - public метод который создает tcp-соединение с переданным через конструктор сервером (в случае если соединение 
        установить не получилось из-за недоступности сервера, делается еще 2 попытки с интервалом 10с) и 
        отправляет случайную последовательность байт по tcp в формате <размер><данные>, при этом <размер> должен занимать 
        минимальное необходимое количество байт и корректно декодироваться на принимающей стороне
    
    создан класс MyListener и:
        - конструктор, принимающий на вход реквизиты интерфейса на котором должен работать сервис
        - public метод который запускает tcp-сервис на переданных через конструктор ip-адресе и порту
        - protected метод который получает последовательность байт по tcp в формате <размер><данные> декодирует их 
        и выводит в stdout размер в виде целого числа и первые 16 байт (не более 16 байт) в hex-формате блока данных

    в функции main 
        - для роли отправителя с использованием класса MySender выполняется одна отправка
        - для роли принимающей стороны с использованием класса MyListener поднимается tcp-сервис и 
        ожидает/обрабатывает подключениядля приложения 

должен быть написан bash-скрипт в котором:
    - получается список сетевых интерфейсов для которых установлен адрес ipv4, 
    включая локальный, извлекается его ipv4-адрес и добавляется в список ILIST
    - объявляется переменная MIN_PORT в которой указывается целочисленное значение, 
    например, 60000, используемое в качестве номера порта
    - для каждого элемента SERVER_IP массива в переменной ILIST:
        - запускается приложение в роли принимающей стороны, ожидающее подключения на IP-адресе SERVER_IP и порту который вычисляется 
        как MIN_PORT + <порядковый номер элемента массива>, stdout каждого приложения перенаправляется в отдельный временный файл 
        - запускается приложение в роли отправителя, подключающееся по IP-адресу SERVER_IP и порту который вычисляется как 
        MIN_PORT + <порядковый номер элемента массива>

- после запуска приложений для каждого элемента массива и завершения отправки данных выводится сообщение "Done. Press any key to exit." и ожидается нажатие клавиши
- после нажатия клавиши в скрипте выполняется явное принудительное завершение всех процессов приложения, запущенных в роли принимающей 
стороны, с выводом PID завершаемого процесса
- удаление всех временных файлов
'''
import argparse
import sys

def main():
    parser = argparse.ArgumentParser(description='Программа для отправки и приема данных')
    #обязательный аргумент, который определяет роль приложения
    parser.add_argument('--role', choices=['send', 'recieve'], required=True, help='Роль приложения: send или recieve')
    
    #опциональные аргументы, которые требуются в зависимости от указанной роли
    parser.add_argument('--server', type=str, help='Имя сервера для отправки (если указана роль send)')
    parser.add_argument('--ip', type=str, help='Адрес сервера для прослушивания (если указана роль recieve)')
    parser.add_argument('--port', type=str, help='Порт сервера прослушивания (если указана роль recieve)')
    
    args = parser.parse_args()
    
    if args.role == 'send':
        print(f'Создаем приложение для отправки данных')
        if not args.server:
            print(f'Не указан адрес для отправки')
            sys.exit(1)
    elif args.role == 'recieve':
        print(f'Создаем приложение для приема данных')
        if not args.ip or args.port:
            print(f'Не указан адрес для отправки')
            sys.exit(1)

if __name__ == '__main__':
    main()